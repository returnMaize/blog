## 3.x 对比 2.x 的优点

:::tip
本章并不会列出所有 3.x 与 2.x 的区别，也没有必要。只会针对一些相对比较重要的变化进行说明。
:::

### 源码管理方面

`vue 3.x` 采用 monorepo 多包管理方式进行代码管理，将不同功能模块拆分成单独的包。每个独立包都拥有自己的单元测试和 `package.json`，包和包之间的依赖关系非常明确。便于阅读和维护，除此之外有些包可以独立于 `vue` 单独使用，例如 `reactivity` 就可以单独使用，当我们只想使用 `vue` 的响应式模块时，这将非常有用的。

### 运行性能方面
- `vue 3.x` 引入 `tree sharking`，对于使用到的 API 将不会被打包到线上，减少了代码体积
- 使用 Proxy 代替 Object.defineProperty，Proxy API 的性能是要比 Object.defineProperty 要高。此外，对于嵌套层级很深的对象，`vue 3.x` 不会进行无脑代理，而是会在 `getter` 中使用 Proxy，只有当这个对象被访问到时才会进行代理。
- 我们知道在 `vue 2.x` 时组件更新时会 `diff` 组件中所有节点，这种方式在遇到静态节点较多的组件时会做很多无用的 diff，`vue 3.x` 为此对编译进行了优化，新增 `block tree`，它能将静态节点和动态节点隔离开来，区分出静态节点块和动态节点块。在组件更新时，`vue` 只会 `diff` 动态节点块。


### 开发方面
- 新增 `Composition API`，能够将一个功能涉及到的 data、computed、methods... 放到一个 hook 函数中，拥有更好的代码组织能力，在提高维护性和阅读性的同时，也大大提高了相同逻辑的复用性。
- 源码采用 `TypeScript` 编写，对 ts 有很好的支持
- Proxy 代替 Object.defineProperty，在修改响应式数据时无需使用特殊的 API 来触发响应式

