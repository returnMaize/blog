(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{285:function(t,s,a){"use strict";a.r(s);var n=a(14),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"js-中的内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-中的内存管理"}},[t._v("#")]),t._v(" JS 中的内存管理")]),t._v(" "),s("p",[t._v("JS 中的内存管理是自动的，它没有为我们提供手动开辟内存空间的 API，也没有给我们提供释放内存 API。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// JS 引擎自动为你开辟一块内存空间")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hjx'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// JS 引擎自动释放这块内存空间")]),t._v("\nobj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n")])])]),s("h2",{attrs:{id:"垃圾"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾"}},[t._v("#")]),t._v(" 垃圾")]),t._v(" "),s("p",[t._v("什么时候垃圾？")]),t._v(" "),s("p",[t._v("垃圾就是开辟了一片空间，但是没有使用这片空间，那这边空间就可以叫做垃圾。")]),t._v(" "),s("p",[t._v("下面我们来看看 JS 是通过什么方式回收垃圾，已经常见的垃圾回收算法（GC）")]),t._v(" "),s("h2",{attrs:{id:"常见的-gc-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的-gc-算法"}},[t._v("#")]),t._v(" 常见的 GC 算法")]),t._v(" "),s("ul",[s("li",[t._v("引用计数算法")]),t._v(" "),s("li",[t._v("标记清除算法")]),t._v(" "),s("li",[t._v("标记整理算法")]),t._v(" "),s("li",[t._v("分代回收（V8）")])]),t._v(" "),s("h2",{attrs:{id:"引用计数算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[t._v("#")]),t._v(" 引用计数算法")]),t._v(" "),s("p",[t._v("JS 引擎为每一个块开辟的内存空间都维护一个引用数值。这块空间被引用一次数值 +1，断开引用数值就 -1，如果发现某块空间引用数值为 0。那么这块内存空间就会被视为垃圾被释放掉。")]),t._v(" "),s("p",[s("strong",[t._v("示例")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hjx'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * foo 执行，开辟了一块空间 {name: 'hjx'}\n * 执行完成，空间为被引用，引用数值为 0\n * 垃圾，空间释放\n */")]),t._v("\n")])])]),s("p",[t._v("但这种垃圾回收存在很大的弊端，当遇到循环引用时，两个相互引用的对象它们的引用值永远不会为零。")]),t._v(" "),s("p",[s("strong",[t._v("示例")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hjx'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'cmx'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  obj1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("love "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj2\n  obj2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("love "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj1\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * foo 执行，开辟空间 {name: 'hjx'} 和 {name: 'cmx'}\n * obj1.love = obj2 内存空间 {name: 'cmx'} 引用计数为1\n * obj2.love = obj1 内存空间 {name: 'hjx'} 引用计数为1\n * foo 执行完毕（内存无法释放）\n */")]),t._v("\n")])])]),s("p",[s("strong",[t._v("优点：")]),t._v(" 发现垃圾立马清楚")]),t._v(" "),s("p",[s("strong",[t._v("缺点：")]),t._v(" 无法清除循环引用")]),t._v(" "),s("h2",{attrs:{id:"标记清除算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[t._v("#")]),t._v(" 标记清除算法")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("从根对象开始递归遍历所有可达对象并进行标记（这里的可达对象就是能够通过根对象直接或间接访问到的对象）")])]),t._v(" "),s("li",[s("p",[t._v("遍历内存堆中所有对象，没有被标记的对象都是垃圾。")])])]),t._v(" "),s("p",[s("strong",[t._v("示例")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hjx'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'cmx'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  obj1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("love "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj2\n  obj2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("love "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj1\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 通过根对象 window 查找可达对象，没有可达对象（这里不考虑函数）\n * foo 执行完成，遍历堆中对象，发现 {name: 'hjx'} 和 {name: 'cmx'}\n * 两个内存空间未被标记，都是垃圾进行空间释放\n */")]),t._v("\n")])])]),s("p",[s("strong",[t._v("优点")]),t._v("：对比引用计数解决了循环引用问题")]),t._v(" "),s("p",[s("strong",[t._v("缺点")]),t._v("：释放垃圾内存空间时原地释放，导致空间碎片化")]),t._v(" "),s("h2",{attrs:{id:"标记整理算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记整理算法"}},[t._v("#")]),t._v(" 标记整理算法")]),t._v(" "),s("p",[t._v("和标记清除算法一样，不同的是。标记整理算法在释放空间前会将内存空间进行整理，有用的对象空间会放到一边，垃圾内存空间放到另一边，整理完成后释放垃圾空间。")]),t._v(" "),s("p",[s("strong",[t._v("优点")]),t._v("：减少空间碎片化")]),t._v(" "),s("p",[s("strong",[t._v("缺点")]),t._v("：整理空间需要时间，整理和释放空间都会阻塞主线程代码的执行。")]),t._v(" "),s("h2",{attrs:{id:"分代回收-v8-垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分代回收-v8-垃圾回收机制"}},[t._v("#")]),t._v(" 分代回收（V8 垃圾回收机制）")]),t._v(" "),s("p",[t._v("V8 将内存空间一分为二，分为新生代和老生代。新生代主要存放一些周期性较短较小的对象（如函数执行时产生的局部变量），老生代主要存放一些周期性长，内存占用大的对象。")]),t._v(" "),s("h4",{attrs:{id:"新生代回收原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新生代回收原理"}},[t._v("#")]),t._v(" 新生代回收原理")]),t._v(" "),s("p",[t._v("新生代的空间会被均匀分为两部分，分别是 from 和 to，程序运行时使用到的内存都是 from 中的，to 空间会处于待定状态。v8 会通过标记清除算法将所有的可达对象全部拷贝到 to 空间中，然后存在 from 中的都会被视为垃圾进行清除。然后 V8 会将 from 变为 to，而 to 变为 from。这样便完成了新生代的垃圾回收。")]),t._v(" "),s("p",[t._v("补充：")]),t._v(" "),s("ul",[s("li",[t._v("拷贝对象需要花费较多的时间，所以新生代的内存一般比较小。")]),t._v(" "),s("li",[t._v("由于新生代空间小，所以很有可能出现 from 空间超出的情况。对于这种情况，v8 会将那些经历了两次 GC 还存活下来的对象进行晋升，将它们放到老生代内存中。")])]),t._v(" "),s("h4",{attrs:{id:"老生代回收原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#老生代回收原理"}},[t._v("#")]),t._v(" 老生代回收原理")]),t._v(" "),s("p",[t._v("老生代的空间会通过标记清除进行垃圾回收，但如果老生代中的最大空闲内存不足以存放新生代中晋升的对象时，这是 v8 又会采用标记整理算法进行垃圾回收和空间整理。")]),t._v(" "),s("p",[t._v("补充：")]),t._v(" "),s("ul",[s("li",[t._v("标记算法在标记时是会阻塞 JS 主线程代码运行的，v8 为此通过增量标记算法对其进行了优化。v8 并不会一次性标记完所有的对象，而是将标记操作分为了一个个的子任务，标记一点，执行一段 js 代码，再标记一点，再执行一点 js 代码。通过这种增量标记的方式，让标记操作不会长时间占用主线程。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);