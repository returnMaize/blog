(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{301:function(t,s,a){"use strict";a.r(s);var v=a(14),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),s("p",[t._v("当我们在浏览器输入框中输入 URL 按下回车到页面渲染完成到最后关闭页面这整个流程我们可以称之为页面的生命周期，本章我们将通过分析页面从请求到关闭这整个生命周期来寻找可以优化的点。从而使得页面的性能达到 web 性能指标，提高用户体验。")]),t._v(" "),s("h2",{attrs:{id:"分析页面生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分析页面生命周期"}},[t._v("#")]),t._v(" 分析页面生命周期")]),t._v(" "),s("ul",[s("li",[t._v("URL 输入")]),t._v(" "),s("li",[t._v("DNS 解析域名为 IP")]),t._v(" "),s("li",[t._v("建立 TCP 链接")]),t._v(" "),s("li",[t._v("资源传输")]),t._v(" "),s("li",[t._v("页面开始渲染")]),t._v(" "),s("li",[t._v("渲染 DOM tree")]),t._v(" "),s("li",[t._v("渲染 CSS tree")]),t._v(" "),s("li",[t._v("合并为 render tree")]),t._v(" "),s("li",[t._v("完成页面渲染")]),t._v(" "),s("li",[t._v("用户交互")]),t._v(" "),s("li",[t._v("页面关闭")])]),t._v(" "),s("h2",{attrs:{id:"dns-解析优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns-解析优化"}},[t._v("#")]),t._v(" DNS 解析优化")]),t._v(" "),s("p",[s("strong",[t._v("DNS 预解析")])]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("rel")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("dns-prefetch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("href")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("https://xxx.com"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])])]),s("p",[t._v("注意：预解析的域名需要和当前资源域名不一致，否则预解析毫无意义。另外同一个域名避免重复预解析，预解析也是需要耗费时间的。")]),t._v(" "),s("p",[s("strong",[t._v("延迟 DNS 缓存时间")])]),t._v(" "),s("p",[t._v("注意：对于一些很少会访问到的域名，可以不进行缓存")]),t._v(" "),s("h2",{attrs:{id:"tcp-链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-链接"}},[t._v("#")]),t._v(" TCP 链接")]),t._v(" "),s("p",[s("strong",[t._v("http1.1")])]),t._v(" "),s("p",[t._v("长链接保持 tcp 链接")]),t._v(" "),s("p",[t._v("缺点：资源是依次传输的，容易造成队头阻塞。想象一下，如果传输的过程中遇到一个非常大的资源，那么将会阻塞后续资源的加载。")]),t._v(" "),s("p",[s("strong",[t._v("http2")])]),t._v(" "),s("p",[t._v("多工长链接：在长链接的基础上实现并行传输。避免了队头阻塞情况的发生。")]),t._v(" "),s("h2",{attrs:{id:"资源传输"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#资源传输"}},[t._v("#")]),t._v(" 资源传输")]),t._v(" "),s("p",[s("strong",[t._v("资源压缩")])]),t._v(" "),s("p",[t._v("对较大的资源进行 gzip 压缩，提高传输时的速度")]),t._v(" "),s("p",[t._v("注意：如果资源较小，就不要进行 gzip 压缩了，浏览器解压也是需要时间的。如果资源太小反而会适得其反。")]),t._v(" "),s("p",[s("strong",[t._v("资源缓存")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("强缓存（浏览器不会发起请求，不存在资源传输）")]),t._v(" "),s("p",[t._v("可以通过给资源添加 hash 的方式，在配合浏览器的强缓存机制完美实现资源缓存")]),t._v(" "),s("p",[t._v("设置请求头 expires （http 1.1）设置的过期时间是一个具体时间，当客户端时间和服务端时间不一致时容易出现问题。")]),t._v(" "),s("p",[t._v("设置请求头 cache-control （http 2）设置的过期时间是一个相对客户端的时间")])]),t._v(" "),s("li",[s("p",[t._v("协商缓存（浏览器发起资源请求，通过对比决定取本地缓存还是重新资源传输）")]),t._v(" "),s("p",[t._v("设置响应头 Last-Modified 设置的为上一次资源改变的时间，浏览器拿到后会和 If-Modified-Since 时间进行对比，如果不相同则资源发生变化，重新请求资源（缺点：仅改变资源名也会导致资源重新传输）")]),t._v(" "),s("p",[t._v("设置响应头 Etag，Etag 是通过资源文件生成的 hash，只要资源内容不发生变化，hash 便不会发生变化。通过对比 Etag 和 If-None-Match 来决定资源取本地缓存还是重新传输")])])]),t._v(" "),s("p",[s("strong",[t._v("cdn 加速")])]),t._v(" "),s("p",[t._v("对于第三方资源，我们可以利用 cdn 资源分发，能够缩短客户端和服务器的距离，提高资源传输的速度。")]),t._v(" "),s("p",[s("strong",[t._v("代码分割，资源懒加载")])]),t._v(" "),s("ul",[s("li",[t._v("我们可以通过合理的代码分割和懒加载，减少很多不必要资源的请求提高页面性能。以常见的 SPA 应用举例，对于那些没有加载到的前端路由对应的资源，我们可以对其进行分割，然后通过路由懒加载的形式减少不必要的资源加载。提高代码覆盖率。")]),t._v(" "),s("li",[t._v("首页不加载非关键的 css（媒体查询的 css 不阻塞渲染）")]),t._v(" "),s("li",[t._v("js 脚本使用 defer 进行加载（无需考虑执行顺序的 js 可以使用 async 加载）")])]),t._v(" "),s("p",[s("strong",[t._v("css 加载")])]),t._v(" "),s("ul",[s("li",[t._v("避免使用 @import 加载 css，应使用 link 标签。@import 是阻塞型加载，而 link 是并行加载。")]),t._v(" "),s("li",[t._v("使用 link 标签中的 prelad 预加载 css")])]),t._v(" "),s("h2",{attrs:{id:"页面渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染"}},[t._v("#")]),t._v(" 页面渲染")]),t._v(" "),s("p",[s("strong",[t._v("DOM tree 构建")])]),t._v(" "),s("p",[t._v("减少 html 中的注释，移除注释掉的代码。")]),t._v(" "),s("p",[s("strong",[t._v("CSS tree 构建")])]),t._v(" "),s("ul",[s("li",[t._v("避免使用很泛的选择器，如通配符选择器、标签选择器，这些选择器在构建 css tree 过程中需要查找很多元素，影响构建速度。建议使用类选择器。")]),t._v(" "),s("li",[t._v("删除没有使用到的 css")])]),t._v(" "),s("h2",{attrs:{id:"用户交互"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用户交互"}},[t._v("#")]),t._v(" 用户交互")]),t._v(" "),s("ul",[s("li",[t._v("用户操作合理使用防抖和节流")]),t._v(" "),s("li",[t._v("避免元素几何属性发生变化导致页面重绘回流")]),t._v(" "),s("li",[t._v("尽量使用 css 实现动画，使用 js 完成动画使用 requestAnimationFrame 实现，避免使用 setInterval。")])])])}),[],!1,null,null,null);s.default=_.exports}}]);